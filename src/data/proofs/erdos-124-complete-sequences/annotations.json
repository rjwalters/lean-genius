[
  {
    "id": "ann-intro",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 3, "endLine": 48},
    "type": "concept",
    "title": "The First AI-Solved Open Problem",
    "content": "**Erdos Problem #124** (November 2025)\n\nThis proof marks a historic milestone: the **first open mathematical conjecture solved autonomously by AI**.\n\n**The Story**:\n- 1996: Burr, Erdos, Graham, Li pose the problem\n- 1997: Erdos reformulates, accidentally creating ambiguity\n- 2025: Harmonic's Aristotle solves it in 6 hours\n- Lean verifies the proof in 1 minute\n\n**Key Quote** (Terence Tao): \"Aristotle solved 'a' version of this problem (indeed, with an olympiad-style proof), but not 'the' version.\"\n\nThe \"weak\" version (including $d^0 = 1$) was solved. The \"strong\" version remains open.",
    "significance": "critical",
    "relatedConcepts": ["Erdos problems", "AI theorem proving", "formal verification"]
  },
  {
    "id": "ann-problem-statement",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 6, "endLine": 13},
    "type": "definition",
    "title": "The Problem Statement",
    "content": "**Complete Sequences of Integer Powers**\n\nGiven bases $d_1, d_2, \\ldots, d_k$ with $d_i \\geq 2$, let $P(d_i, 0)$ be the set of numbers whose base-$d_i$ representation uses only digits 0 and 1.\n\nFor example, in base 3:\n- $P(3, 0) = \\{0, 1, 3, 4, 9, 10, 12, 13, \\ldots\\}$\n- These are: $0, 1, 3^1, 3^1+1, 3^2, 3^2+1, 3^2+3, \\ldots$\n\n**The Question**: If $\\sum_{i=1}^{k} \\frac{1}{d_i - 1} \\geq 1$, can every natural number be written as a sum $\\sum_i a_i$ where each $a_i \\in P(d_i, 0)$?\n\n**Answer**: YES!",
    "mathContext": "P(d,0) = numbers with 0/1 digits in base d",
    "significance": "critical",
    "relatedConcepts": ["digit representation", "bases", "complete sequences"]
  },
  {
    "id": "ann-two-versions",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 10, "endLine": 13},
    "type": "note",
    "title": "The Two Versions",
    "content": "**Weak vs Strong: A 30-Year Ambiguity**\n\n| Aspect | Weak (Solved) | Strong (Open) |\n|--------|---------------|---------------|\n| Powers | $P(d,0)$: includes $d^0 = 1$ | $P(d,1)$: excludes 1 |\n| GCD | Not required | $\\gcd(d_1,\\ldots,d_k) = 1$ |\n| Difficulty | Olympiad-level | Research-level |\n\n**Why the difference matters**:\n- With $d^0 = 1$: We always have 1 available, gaps are easily controlled\n- Without 1: Gaps can approach $d_i$, requiring \"something like Baker's theorem\" (Tao)\n\n**The formalization revealed**: Erdos's 1997 reformulation accidentally made the problem easier than Burr et al.'s 1996 version.\n\n**Thomas Bloom**: \"If something like this worked, surely the combined talents of the original authors would have spotted it.\"",
    "mathContext": "P(d,0) vs P(d,1) distinction",
    "significance": "major",
    "relatedConcepts": ["problem formulation", "ambiguity", "strong conjecture"]
  },
  {
    "id": "ann-ai-story",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 20, "endLine": 23},
    "type": "note",
    "title": "The AI Story",
    "content": "**Harmonic's Aristotle: First AI Mathematician**\n\n**Timeline**:\n- Boris Alexeev selects several Erdos problems\n- Launches Aristotle beta, goes to sleep\n- Wakes up to email: \"Problem 124 resolved\"\n\n**His reaction**: \"Not emotionally prepared to wake up to an email that Aristotle had successfully resolved Problem 124.\"\n\n**The Numbers**:\n- 6 hours solving time\n- 1 minute verification in Lean\n- 100% autonomy - no human assistance\n\n**What Aristotle found**: An elegant proof using Brown's criterion - a classic result that combines perfectly with the greedy construction. The proof is \"olympiad-style\" - something a skilled human could have found, but didn't for 30 years.\n\n**Vlad Tenev** (Harmonic founder): \"Vibe proving is here.\"",
    "significance": "major",
    "relatedConcepts": ["Harmonic", "Aristotle", "AI mathematics"]
  },
  {
    "id": "ann-proof-strategy",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 25, "endLine": 32},
    "type": "concept",
    "title": "Proof Strategy Overview",
    "content": "**The Five-Step Proof**\n\n1. **Construct `u_seq`**: Greedily select the smallest available power at each step\n2. **Track sources**: `chosen_index` and `chosen_exponent` record which base/power was used\n3. **Verify gaps**: Show $u_{n+1} \\leq 1 + u_0 + \\cdots + u_n$\n4. **Apply Brown's criterion**: Sequences with small gaps are complete\n5. **Decompose**: Convert subset sums back to 0/1 digit representations\n\n**Why this works**: The reciprocal condition $\\sum 1/(d_i-1) \\geq 1$ precisely controls how fast the sequence grows, ensuring gaps stay small enough for Brown's criterion.",
    "mathContext": "Five-step proof architecture",
    "significance": "critical",
    "relatedConcepts": ["proof structure", "Brown's criterion", "greedy algorithm"]
  },
  {
    "id": "ann-namespace",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 57, "endLine": 60},
    "type": "tactic",
    "title": "Namespace and Opens",
    "content": "**Lean Setup**\n\n```lean\nnamespace Erdos124\nopen Nat Finset Filter\nopen scoped Real\n```\n\n- `namespace Erdos124`: Groups all definitions under `Erdos124.*`\n- `open Nat Finset Filter`: Brings natural number operations, finite sets, and filter theory into scope\n- `open scoped Real`: Enables real number notations without polluting the namespace\n\n**Key imports from Mathlib**:\n- `Nat.digits`: Digit representation in arbitrary bases\n- `Finset.sum`: Finite summations\n- `Filter.Eventually`: \"Eventually true\" predicates for the formal conjectures version",
    "mathContext": "Lean namespace management",
    "significance": "supporting",
    "relatedConcepts": ["Lean syntax", "Mathlib imports", "namespaces"]
  },
  {
    "id": "ann-algebraic-gap",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 62, "endLine": 71},
    "type": "lemma",
    "title": "The Algebraic Gap Lemma",
    "content": "**Algebraic Foundation**\n\n```lean\nlemma algebraic_gap (k : ℕ) (d : Fin k → ℕ) (y : Fin k → ℕ)\n    (h_ge : ∀ i, 2 ≤ d i)\n    (h_sum : 1 ≤ ∑ i, (1 : ℚ) / (d i - 1))\n    (h_pos : ∀ i, 0 < y i) :\n    ∀ m : ℕ, (∀ i, m ≤ y i) → (m : ℚ) ≤ 1 + ∑ i, ((y i : ℚ) - 1) / (d i - 1)\n```\n\n**What this says**: If $m$ is a lower bound for all $y_i$, then:\n$$m \\leq 1 + \\sum_i \\frac{y_i - 1}{d_i - 1}$$\n\n**Why it matters**: This inequality is the algebraic engine that makes the gap property work. The reciprocal condition ensures the right-hand side grows fast enough.",
    "mathContext": "m ≤ 1 + sum of scaled terms",
    "significance": "major",
    "relatedConcepts": ["algebraic inequality", "reciprocal condition", "gap bound"]
  },
  {
    "id": "ann-reciprocal-condition",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 68, "endLine": 68},
    "type": "insight",
    "title": "The Reciprocal Condition",
    "content": "**Why $\\sum \\frac{1}{d_i - 1} \\geq 1$?**\n\nThis condition controls the \"density\" of available powers.\n\n**Intuition**: Each base $d_i$ contributes powers $1, d_i, d_i^2, \\ldots$ These grow exponentially, creating gaps. The reciprocal condition ensures enough bases to fill all gaps.\n\n**Example**: $d_1 = 3, d_2 = 5, d_3 = 15$\n$$\\frac{1}{3-1} + \\frac{1}{5-1} + \\frac{1}{15-1} = \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{14} \\approx 0.82 < 1$$\n\nThis fails the condition! Indeed, not all integers are representable.\n\n**Satisfying examples**:\n- $d = 2$: $\\frac{1}{2-1} = 1$ (binary works alone!)\n- $d_1 = 3, d_2 = 3$: $\\frac{1}{2} + \\frac{1}{2} = 1$\n- $d_1 = 2, d_2 = 3, d_3 = 6$: $1 + \\frac{1}{2} + \\frac{1}{5} > 1$",
    "mathContext": "Reciprocal sum controls density of powers",
    "significance": "critical",
    "relatedConcepts": ["density", "gap control", "necessity"]
  },
  {
    "id": "ann-browns-criterion",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 100, "endLine": 128},
    "type": "lemma",
    "title": "Brown's Criterion",
    "content": "**Brown's Criterion for Complete Sequences**\n\nA sequence $f(0), f(1), f(2), \\ldots$ of positive integers is **complete** (every positive integer is a subset sum) if:\n\n1. $f(0) = 1$\n2. $f$ is non-decreasing (monotone)\n3. **Small gaps**: $f(n+1) \\leq 1 + \\sum_{i=0}^{n} f(i)$\n\n**Proof Idea**: By induction on $n$.\n- Base: $\\{1\\}$ represents 1\n- Step: If $m > S_n = f(0) + \\cdots + f(n)$, then $m - f(n+1) \\leq S_n$ by the gap condition\n- So $m - f(n+1)$ is representable by smaller terms\n- Adding $f(n+1)$ gives $m$\n\n**This is the KEY INSIGHT**: Convert the representation problem to a gap-checking problem!",
    "mathContext": "f(n+1) - 1 <= sum of previous terms",
    "significance": "critical",
    "relatedConcepts": ["subset sums", "complete sequences", "gap condition"]
  },
  {
    "id": "ann-browns-proof-structure",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 107, "endLine": 128},
    "type": "tactic",
    "title": "Brown's Criterion Proof",
    "content": "**Proof Structure in Lean**\n\n```lean\nset Sn : ℕ → ℕ := fun n => ∑ i ∈ Finset.range (n + 1), f i\n```\n\n$S_n$ = partial sum through index $n$.\n\n**The induction**:\n1. For each $n$, prove: $\\forall m \\leq S_n$, $m$ is a subset sum of $\\{f(0), \\ldots, f(n)\\}$\n2. Base case ($n = 0$): $S_0 = f(0) = 1$, so $m \\in \\{0, 1\\}$ works\n3. Inductive step: If $m \\leq S_n$, use IH. If $m > S_n$, then $m - f(n+1) \\leq S_n$ by gap condition\n\n**Key Lean tactics**:\n- `induction' n with n ih`: Strong induction\n- `by_cases h_case : m ≤ Sn n`: Case split\n- `use s ∪ { n + 1 }`: Extend the subset",
    "mathContext": "Induction on partial sums",
    "significance": "major",
    "relatedConcepts": ["induction", "partial sums", "case analysis"]
  },
  {
    "id": "ann-min-index",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 137, "endLine": 138},
    "type": "definition",
    "title": "Finding the Minimum Power",
    "content": "**Selecting the Smallest Power**\n\n```lean\nnoncomputable def min_index {k : ℕ} (d : Fin k → ℕ) (e : Fin k → ℕ) (h : k ≠ 0) : Fin k :=\n  Classical.choose (Finset.exists_min_image ...)\n```\n\n**What this does**: Given current exponents $e_1, \\ldots, e_k$, find the index $i$ that minimizes $d_i^{e_i}$.\n\n**Why `noncomputable`?** Uses `Classical.choose` to pick one minimizer when there could be ties. This is fine for existence proofs but can't compute actual values.\n\n**Example**: With $d_1 = 2, d_2 = 3$ and $e_1 = 2, e_2 = 1$:\n- $d_1^{e_1} = 2^2 = 4$\n- $d_2^{e_2} = 3^1 = 3$\n- `min_index` returns index 2 (giving value 3)",
    "mathContext": "argmin of d_i^{e_i}",
    "significance": "major",
    "relatedConcepts": ["minimum selection", "Classical.choose", "noncomputable"]
  },
  {
    "id": "ann-next-e",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 140, "endLine": 143},
    "type": "definition",
    "title": "Updating Exponents",
    "content": "**Increment the Chosen Exponent**\n\n```lean\nnoncomputable def next_e {k : ℕ} (d : Fin k → ℕ) (e : Fin k → ℕ) : Fin k → ℕ :=\n  if h : k = 0 then e else\n  let i := min_index d e h\n  Function.update e i (e i + 1)\n```\n\n**What this does**: \n1. Find $i$ = index of minimum power\n2. Return new exponents: $e'_j = e_j$ for $j \\neq i$, and $e'_i = e_i + 1$\n\n**`Function.update`**: Mathlib's way to modify one value in a function.\n\n**The edge case**: If $k = 0$ (no bases), return `e` unchanged. This makes the definition total.",
    "mathContext": "e' = e with e_i incremented",
    "significance": "key",
    "relatedConcepts": ["Function.update", "exponent tracking", "state update"]
  },
  {
    "id": "ann-e-seq",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 145, "endLine": 147},
    "type": "definition",
    "title": "Exponent Sequence",
    "content": "**Tracking Exponents Over Time**\n\n```lean\nnoncomputable def e_seq {k : ℕ} (d : Fin k → ℕ) : ℕ → Fin k → ℕ\n  | 0 => (fun _ => 0)\n  | n + 1 => next_e d (e_seq d n)\n```\n\n**What this gives**: At step $n$, `e_seq d n i` is the exponent for base $d_i$.\n\n**Initial state** ($n = 0$): All exponents are 0\n**Transition**: Apply `next_e` to get the next state\n\n**Example trace** with $d_1 = 2, d_2 = 3$:\n- $n=0$: $e = (0, 0)$, powers are $(1, 1)$\n- $n=1$: pick min (either), say $e = (1, 0)$, powers $(2, 1)$\n- $n=2$: pick min (index 2), $e = (1, 1)$, powers $(2, 3)$\n- $n=3$: pick min (index 1), $e = (2, 1)$, powers $(4, 3)$",
    "mathContext": "e_seq tracks all exponents",
    "significance": "major",
    "relatedConcepts": ["recursion", "state sequence", "exponent tracking"]
  },
  {
    "id": "ann-u-seq",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 149, "endLine": 154},
    "type": "definition",
    "title": "The Main Sequence",
    "content": "**The Greedy Power Sequence**\n\n```lean\nnoncomputable def u_seq {k : ℕ} (d : Fin k → ℕ) (n : ℕ) : ℕ :=\n  let e := e_seq d n\n  if h : k ≠ 0 then\n    let i := min_index d e h\n    d i ^ e i\n  else 1\n```\n\n**The key sequence!** At step $n$:\n1. Get current exponents from `e_seq`\n2. Find the index $i$ minimizing $d_i^{e_i}$\n3. Return that minimum power\n\n**Property**: `u_seq` is exactly the sequence fed to Brown's criterion.\n\n**Example sequence** for $d_1 = 2, d_2 = 3$:\n$$u = (1, 2, 3, 4, 8, 9, 16, 27, 32, 64, 81, \\ldots)$$\n\nNotice: it's non-decreasing and the gaps are controlled!",
    "mathContext": "u_n = min(d_i^{e_i})",
    "significance": "critical",
    "relatedConcepts": ["greedy sequence", "power selection", "Brown's criterion input"]
  },
  {
    "id": "ann-greedy-construction",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 130, "endLine": 154},
    "type": "concept",
    "title": "The Greedy Construction",
    "content": "**Greedy Algorithm for Sequence Construction**\n\n**Algorithm**:\n1. Start with exponents $e_1 = e_2 = \\cdots = e_k = 0$\n2. At step $n$:\n   - Find $i$ minimizing $d_i^{e_i}$ (the smallest available power)\n   - Set $u_n = d_i^{e_i}$\n   - Increment $e_i \\leftarrow e_i + 1$\n\n**Example** with $d_1 = 2, d_2 = 3$:\n- Step 0: min is $2^0 = 3^0 = 1$, pick any, $u_0 = 1$\n- Step 1: $2^1 = 2 < 3^0 = 1$? No, $2 > 1$. But we already used $3^0$...\n- Sequence grows: $1, 2, 3, 4, 8, 9, 16, 27, \\ldots$\n\n**Why greedy works**: By always taking the smallest power, we minimize gaps and ensure Brown's criterion applies.",
    "mathContext": "min_index selects smallest power",
    "significance": "major",
    "relatedConcepts": ["greedy algorithm", "sequence construction", "power selection"]
  },
  {
    "id": "ann-u-seq-monotone",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 156, "endLine": 176},
    "type": "lemma",
    "title": "Monotonicity",
    "content": "**The Sequence is Non-Decreasing**\n\n```lean\nlemma u_seq_monotone {k : ℕ} {d : Fin k → ℕ} (hk : k ≠ 0) (h_ge : ∀ i, 2 ≤ d i) :\n    Monotone (u_seq d)\n```\n\n**Why this holds**: We always pick the minimum power. After picking $d_i^{e_i}$, we increment $e_i$, so the new power $d_i^{e_i+1} \\geq d_i^{e_i} \\cdot 2 > d_i^{e_i}$.\n\nMeanwhile, all other powers stay the same or increase. So the new minimum is at least the old minimum.\n\n**Required for Brown's criterion**: Monotonicity is one of the three conditions.",
    "mathContext": "u_{n+1} >= u_n",
    "significance": "major",
    "relatedConcepts": ["monotonicity", "Brown's criterion", "greedy property"]
  },
  {
    "id": "ann-u-seq-gap",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 286, "endLine": 318},
    "type": "lemma",
    "title": "The Gap Property",
    "content": "**Key Lemma: The Gap Property**\n\n```lean\nlemma u_seq_gap {k : ℕ} {d : Fin k → ℕ} (hk : k ≠ 0) (h_ge : ∀ i, 2 ≤ d i)\n    (h_sum : 1 ≤ ∑ i, (1 : ℚ) / (d i - 1)) :\n    ∀ n, u_seq d (n + 1) ≤ 1 + ∑ i ∈ Finset.range (n + 1), u_seq d i\n```\n\n**The heart of the proof!** This is where the reciprocal condition $\\sum 1/(d_i-1) \\geq 1$ gets used.\n\n**Intuition**: Each base $d_i$ \"contributes\" roughly $1/(d_i-1)$ to filling gaps. The condition ensures total contribution $\\geq 1$, which suffices for the gap bound.\n\n**This lemma uses**: `algebraic_gap` to handle the inequality.",
    "mathContext": "Gap bounded by reciprocal condition",
    "significance": "critical",
    "relatedConcepts": ["gap analysis", "reciprocal sum", "bound propagation"]
  },
  {
    "id": "ann-chosen-index-exponent",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 320, "endLine": 324},
    "type": "definition",
    "title": "Tracking Choices",
    "content": "**Recording Which Base Was Chosen**\n\n```lean\nnoncomputable def chosen_index {k : ℕ} (d : Fin k → ℕ) (n : ℕ) (hk : k ≠ 0) : Fin k :=\n  min_index d (e_seq d n) hk\n\nnoncomputable def chosen_exponent {k : ℕ} (d : Fin k → ℕ) (n : ℕ) (hk : k ≠ 0) : ℕ :=\n  e_seq d n (chosen_index d n hk)\n```\n\n**What these record**:\n- `chosen_index d n`: Which base contributed $u_n$\n- `chosen_exponent d n`: What exponent was used\n\n**So we have**: $u_n = d_{\\text{chosen\\_index}(n)}^{\\text{chosen\\_exponent}(n)}$\n\n**Why needed**: For digit decomposition - we need to know which base each power came from.",
    "mathContext": "Recording (base, exponent) for each u_n",
    "significance": "major",
    "relatedConcepts": ["index tracking", "exponent recording", "provenance"]
  },
  {
    "id": "ann-u-seq-eq-power",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 326, "endLine": 328},
    "type": "lemma",
    "title": "Power Equality",
    "content": "**u_seq Equals the Chosen Power**\n\n```lean\nlemma u_seq_eq_power {k : ℕ} {d : Fin k → ℕ} (hk : k ≠ 0) (n : ℕ) :\n    u_seq d n = d (chosen_index d n hk) ^ (chosen_exponent d n hk)\n```\n\n**What this says**: $u_n = d_i^{e}$ where $i$ = `chosen_index` and $e$ = `chosen_exponent`.\n\n**Proof**: Just unfolding definitions - `u_seq` is defined exactly this way.\n\n**Why it matters**: Connects the abstract sequence to concrete (base, exponent) pairs for decomposition.",
    "mathContext": "u_n = d_i^e explicitly",
    "significance": "key",
    "relatedConcepts": ["definitional equality", "power representation"]
  },
  {
    "id": "ann-chosen-pair-injective",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 345, "endLine": 350},
    "type": "lemma",
    "title": "Pairs are Unique",
    "content": "**Each (Index, Exponent) Pair Appears Once**\n\n```lean\nlemma chosen_pair_injective {k : ℕ} {d : Fin k → ℕ} (hk : k ≠ 0) :\n    Function.Injective (fun n => (chosen_index d n hk, chosen_exponent d n hk))\n```\n\n**What this says**: If $(i_m, e_m) = (i_n, e_n)$, then $m = n$.\n\n**Why?** Once we use $d_i^e$, we increment $e_i$. So the same (base, exponent) pair can never be chosen again.\n\n**Critical for digit decomposition**: When we sum powers from base $d_i$, each exponent appears at most once, so the sum has only 0/1 digits!",
    "mathContext": "(index, exponent) pairs are distinct",
    "significance": "critical",
    "relatedConcepts": ["injectivity", "uniqueness", "digit constraint"]
  },
  {
    "id": "ann-digit-decomposition",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 352, "endLine": 400},
    "type": "lemma",
    "title": "Digit Decomposition",
    "content": "**From Subset Sums to 0/1 Digits**\n\n```lean\nlemma digits_of_subset_sum_u_seq {k : ℕ} {d : Fin k → ℕ} (hk : k ≠ 0) (h_ge : ∀ i, 2 ≤ d i)\n    (S : Finset ℕ) :\n    ∃ a : Fin k → ℕ, (∀ i, ((d i).digits (a i)).toFinset ⊆ {0, 1}) ∧\n    ∑ j ∈ S, u_seq d j = ∑ i, a i\n```\n\n**The Decomposition**:\n1. Each $u_n$ is some $d_i^{e_n}$ for a specific base $i$ and exponent $e_n$\n2. The `chosen_pair_injective` lemma ensures each $(i, e)$ pair appears at most once\n3. For each base $i$, sum the powers used: $a_i = \\sum_{e \\in E_i} d_i^e$\n4. Since each exponent appears at most once, $a_i$ has 0/1 digits!\n\n**Example**: If $u_3 = 2^1$ and $u_7 = 2^3$, then $a_1 = 2 + 8 = 10 = (1010)_2$ - only 0/1 digits.",
    "mathContext": "Subset sum → digit representation",
    "significance": "critical",
    "relatedConcepts": ["digit representation", "unique exponents", "base decomposition"]
  },
  {
    "id": "ann-u-seq-zero",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 402, "endLine": 403},
    "type": "lemma",
    "title": "Initial Value",
    "content": "**The Sequence Starts at 1**\n\n```lean\nlemma u_seq_zero {k : ℕ} {d : Fin k → ℕ} : u_seq d 0 = 1\n```\n\n**Why?** At $n = 0$, all exponents are 0, so every base contributes $d_i^0 = 1$. The minimum is 1.\n\n**Required for Brown's criterion**: $f(0) = 1$ is one of the three conditions.\n\n**Proof**: Just `unfold u_seq; aesop` - definition unfolding handles it.",
    "mathContext": "u_0 = 1",
    "significance": "key",
    "relatedConcepts": ["initial condition", "Brown's criterion", "d^0 = 1"]
  },
  {
    "id": "ann-k-nonzero",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 405, "endLine": 406},
    "type": "lemma",
    "title": "Non-Empty Base Set",
    "content": "**The Reciprocal Condition Implies k > 0**\n\n```lean\nlemma k_ne_zero_of_sum_eq_one {k : ℕ} {d : Fin k → ℕ}\n    (h : 1 ≤ ∑ i, (1 : ℚ) / (d i - 1)) : k ≠ 0\n```\n\n**Why?** If $k = 0$, the sum is empty, so $\\sum_i = 0 < 1$.\n\n**The `bound` tactic**: A Mathlib tactic for numerical bounds - handles this automatically.\n\n**Why needed**: Many definitions require `k ≠ 0` (can't minimize over an empty set). This lemma lets us derive it from the reciprocal condition.",
    "mathContext": "sum >= 1 implies k > 0",
    "significance": "supporting",
    "relatedConcepts": ["non-emptiness", "bound tactic", "hypothesis derivation"]
  },
  {
    "id": "ann-main-theorem-structure",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 408, "endLine": 436},
    "type": "theorem",
    "title": "Main Theorem",
    "content": "**Erdos Conjecture is True**\n\n```lean\ntheorem erdos_conjecture_true (k : ℕ) (d : Fin k → ℕ)\n    (h_ge : ∀ i, 2 ≤ d i)\n    (h_sum : 1 ≤ ∑ i, (1 : ℚ) / (d i - 1)) :\n    ∀ n, ∃ a : Fin k → ℕ,\n    (∀ i, ((d i).digits (a i)).toFinset ⊆ {0, 1}) ∧ n = ∑ i, a i\n```\n\n**Proof Assembly**:\n\n1. **Apply Brown's criterion** to show all $n$ are subset sums of `u_seq`\n2. **Apply digit decomposition** to convert subset sums to 0/1 representations\n3. **Combine**: Every $n$ has a 0/1 digit representation across bases\n\nThe proof uses `h_dense` for step 1 and `h_terms` for step 2.",
    "mathContext": "Complete theorem with all components",
    "significance": "critical",
    "relatedConcepts": ["main theorem", "proof assembly", "Brown's criterion"]
  },
  {
    "id": "ann-erdos-124-strengthened",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 438, "endLine": 456},
    "type": "theorem",
    "title": "Strengthened Statement",
    "content": "**Erdos Problem #124 (Strengthened)**\n\n```lean\ntheorem erdos_124 : ∀ k, ∀ d : Fin k → ℕ,\n    (∀ i, 2 ≤ d i) → 1 ≤ ∑ i : Fin k, (1 : ℚ) / (d i - 1) →\n    ∀ n, ∃ a : Fin k → ℕ,\n    ∀ i, ((d i).digits (a i)).toFinset ⊆ {0, 1} ∧ n = ∑ i, a i\n```\n\n**Improvements over original statement**:\n- Requires only $d_i \\geq 2$ (not $d_i \\geq 3$)\n- Doesn't require bases to be strictly increasing\n- Works for ALL $n$ (not just \"sufficiently large\")\n\n**Why stronger?** The original had unnecessary hypotheses. Formalization revealed they weren't needed!",
    "mathContext": "Stronger version of the conjecture",
    "significance": "critical",
    "relatedConcepts": ["strengthening", "unnecessary hypotheses", "clean statement"]
  },
  {
    "id": "ann-formal-conjectures",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 458, "endLine": 505},
    "type": "note",
    "title": "Formal Conjectures Compatibility",
    "content": "**Google DeepMind's Formal Conjectures Project**\n\nThe proof matches statements from Google DeepMind's formal-conjectures repository.\n\n**Known Issue**: The original formalization has a typo:\n- Comment says $\\sum 1/(d_i-1) \\geq 1$\n- Lean code says $\\sum 1/(d_i-1) = 1$\n\nBoth versions are proven here:\n- `formal_conjectures_erdos_124`: Original (weaker due to typo)\n- `formal_conjectures_erdos_124_corrected`: Fixed version\n\n**Lesson**: Formal verification catches even documentation errors!\n\n**`∀ᶠ n in atTop`**: Mathlib notation for \"for all sufficiently large $n$\" using filters.",
    "mathContext": "= 1 vs >= 1 typo",
    "significance": "key",
    "relatedConcepts": ["formal verification", "typo detection", "DeepMind", "filters"]
  },
  {
    "id": "ann-worked-example",
    "proofId": "erdos-124-complete-sequences",
    "range": {"startLine": 408, "endLine": 413},
    "type": "example",
    "title": "Worked Example",
    "content": "**Example: Representing 7 with bases 2 and 3**\n\nBases: $d_1 = 2, d_2 = 3$\nCheck: $\\frac{1}{2-1} + \\frac{1}{3-1} = 1 + 0.5 = 1.5 \\geq 1$ \n\n**The u_seq**: $1, 2, 3, 4, 8, 9, 16, 27, \\ldots$\n\n**Representing 7**:\n$7 = 1 + 2 + 4 = u_0 + u_1 + u_3$\n\n**Decomposition**:\n- From base 2: $1 + 2 + 4 = 2^0 + 2^1 + 2^2 = 7$, digits $(111)_2$\n- From base 3: nothing used\n\nSo $a_1 = 7 = (111)_2$ (0/1 digits!) and $a_2 = 0$.\n\n**Alternative**: $7 = 1 + 3 + 3$? No - we can only use each power once, and $3 = 3^1$ appears once in `u_seq`.\n\n$7 = 4 + 3 = 2^2 + 3^1$, so $a_1 = 4 = (100)_2$, $a_2 = 3 = (10)_3$. Both have 0/1 digits!",
    "mathContext": "7 = 4 + 3 = 2^2 + 3^1",
    "significance": "major",
    "relatedConcepts": ["concrete example", "representation", "digit check"]
  }
]
