{
  "id": "halting-problem",
  "title": "Undecidability of the Halting Problem",
  "slug": "halting-problem",
  "description": "Turing's 1936 proof that no algorithm can determine whether an arbitrary program halts, establishing fundamental limits on computation using the diagonal argument.",
  "meta": {
    "author": "Alan Turing (1936)",
    "date": "1936",
    "status": "verified",
    "tags": [
      "computability",
      "undecidability",
      "diagonalization",
      "classic",
      "intermediate"
    ],
    "badge": "from-axioms",
    "sorries": 0,
    "mathlibDependencies": [],
    "originalContributions": [
      "Complete proof with zero imports",
      "Self-contained formalization of diagonal argument",
      "Demonstrates pure logical reasoning in Lean"
    ],
    "dateAdded": "12/21/25"
  },
  "overview": {
    "historicalContext": "Alan Turing published this groundbreaking result in 1936, the same paper where he introduced the Turing machine model of computation. Working independently from Alonzo Church (who proved an equivalent result using lambda calculus), Turing established that there are fundamental limits to what can be computed.\n\nThe halting problem was the first concrete example of an undecidable problem, and it remains the canonical example in computer science education. The proof technique - diagonalization - connects deeply to Cantor's work on uncountability (1891) and Godel's incompleteness theorems (1931).\n\nThe practical implications are profound: no static analysis tool can perfectly detect all infinite loops, no compiler can optimize away all non-terminating code, and no verification system can automatically prove termination for all programs.",
    "problemStatement": "Theorem (Turing, 1936): The halting problem is undecidable.\n\nMore precisely: there is no algorithm $H$ that, given the description of a program $P$ and input $I$, correctly determines whether $P$ halts on $I$:\n\n$$\\nexists H : \\text{Program} \\times \\text{Input} \\to \\{\\text{halts}, \\text{loops}\\}$$\n\nsuch that $H(P, I) = \\text{halts}$ if and only if $P(I)$ terminates.",
    "proofStrategy": "The proof uses diagonalization, similar to Cantor's proof of uncountability:\n\n1. Assume we have a halting oracle $H(p, i)$ that correctly decides if program $p$ halts on input $i$\n2. Construct a diagonal program $D$ that:\n   - Takes a program code $n$ as input\n   - Runs $H(n, n)$ to check if program $n$ halts on itself\n   - Does the opposite: loops if $H$ says halt, halts if $H$ says loop\n3. Apply $D$ to its own code: what does $H(D, D)$ return?\n   - If $H(D, D) = \\text{halts}$: then $D(D)$ loops (by construction)\n   - If $H(D, D) = \\text{loops}$: then $D(D)$ halts (by construction)\n4. Contradiction: $H$ cannot correctly predict $D$'s behavior on itself\n\nThe key insight is self-reference: any decision procedure can be turned against itself.",
    "keyInsights": [
      "Self-reference plus negation creates undecidability",
      "The diagonal program 'does the opposite' of what the oracle predicts",
      "This is the same technique used in Cantor's uncountability proof and Godel's incompleteness",
      "No amount of computational power can solve this - it's a logical impossibility"
    ]
  },
  "sections": [
    {
      "id": "setup",
      "title": "Definitions",
      "startLine": 21,
      "endLine": 33,
      "summary": "Defines halting oracles as functions from (program, input) pairs to Bool, and the diagonal behavior that negates the oracle's self-prediction."
    },
    {
      "id": "diagonal-lemma",
      "title": "The Diagonal Differs",
      "startLine": 35,
      "endLine": 43,
      "summary": "Proves the key lemma: the diagonal behavior always differs from the oracle's prediction at self-application points."
    },
    {
      "id": "main-theorem",
      "title": "No Correct Oracle",
      "startLine": 45,
      "endLine": 76,
      "summary": "Proves that no oracle can correctly predict the diagonal program's behavior, by deriving a contradiction from either prediction."
    },
    {
      "id": "undecidability",
      "title": "Halting Undecidable",
      "startLine": 78,
      "endLine": 97,
      "summary": "Restates the result using logical equivalence: no oracle-code pair achieves correctness for the diagonal behavior."
    },
    {
      "id": "summary",
      "title": "Summary Theorem",
      "startLine": 120,
      "endLine": 131,
      "summary": "Final statement: for any halting oracle, the diagonal program provides an explicit counterexample."
    }
  ],
  "conclusion": {
    "summary": "The undecidability of the halting problem is one of the most important results in computer science. Using the elegant technique of diagonalization, Turing showed that computation has inherent limits - some questions about programs simply cannot be answered algorithmically.\n\nThe formalization captures the essence of the proof: given any proposed oracle, we can construct a diagonal program that the oracle must get wrong. This is not a failure of our current algorithms; it's a fundamental logical barrier.",
    "implications": "The halting problem has profound implications across computer science:\n\n1. Static Analysis Limits - No tool can detect all bugs, infinite loops, or security vulnerabilities. Tools must either miss some problems or report false positives.\n\n2. Rice's Theorem - Generalizes halting: any non-trivial semantic property of programs is undecidable. You can't build a perfect \"does this program do X?\" checker.\n\n3. Verification Limits - Fully automatic program verification is impossible. Interactive theorem provers require human guidance.\n\n4. Compiler Optimizations - Some optimizations (like removing unreachable code) are undecidable in general. Compilers use approximations.\n\n5. The Church-Turing Thesis - This result helped establish that Turing machines capture our intuitive notion of 'algorithm'. The undecidability is about any mechanical procedure.",
    "openQuestions": [
      "What is the computational complexity of approximating the halting problem?",
      "How do real-world static analyzers balance precision and recall?",
      "Can interactive systems (human + machine) solve undecidable problems?"
    ]
  }
}
